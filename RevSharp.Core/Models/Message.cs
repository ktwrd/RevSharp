using System.Net;
using System.Text.Json;
using System.Text.Json.Serialization;
using kate.shared.Helpers;
using RevSharp.Core.Helpers;

namespace RevSharp.Core.Models;

/// <summary>
/// Representation of a Message on Revolt
/// </summary>
public partial class Message : Clientable, ISnowflake
{
    /// <summary>
    /// Unique Id
    /// </summary>
    [JsonPropertyName("_id")]
    public string Id { get; set; }
    /// <summary>
    /// Unique value generated by client sending this message
    /// </summary>
    [JsonPropertyName("nonce")]
    public string? Nonce { get; set; }
    /// <summary>
    /// Id of the channel this message was sent in
    /// </summary>
    [JsonPropertyName("channel")]
    public string ChannelId { get; set; }
    /// <summary>
    /// Id of the user that sent this message
    /// </summary>
    [JsonPropertyName("author")]
    public string AuthorId { get; set; }
    
    /// <summary>
    /// Message content
    /// </summary>
    [JsonPropertyName("content")]
    public string? Content { get; set; }
    /// <summary>
    /// System message
    /// </summary>
    [JsonPropertyName("system")]
    public SystemMessage? SystemMessage { get; set; }
    /// <summary>
    /// Array of attachments
    /// </summary>
    [JsonPropertyName("attachments")]
    public File[]? Attachments { get; set; }
    /// <summary>
    /// Time at which this message was last edited
    /// </summary>
    [JsonPropertyName("edited")]
    public string? EditedAt { get; set; }
    /// <summary>
    /// Attached embeds to this message
    /// </summary>
    [JsonPropertyName("embeds")]
    public BaseEmbed[]? Embeds { get; set; }
    /// <summary>
    /// Array of user ids mentioned in this message
    /// </summary>
    [JsonPropertyName("mentions")]
    public string[]? MentionIds { get; set; }
    /// <summary>
    /// Array of message ids this message is replying to
    /// </summary>
    [JsonPropertyName("replies")]
    public string[]? MessageReplyIds { get; set; }
    /// <summary>
    /// Hashmap of emoji IDs to array of user IDs
    /// </summary>
    [JsonPropertyName("reactions")]
    public Dictionary<string, string[]> Reactions { get; set; }
    /// <summary>
    /// Information about how this message should be interacted with
    /// </summary>
    [JsonPropertyName("interactions")]
    public Interactions Interactions { get; set; }
    /// <summary>
    /// Name and / or avatar overrides for this message
    /// </summary>
    [JsonPropertyName("Masquerade")]
    public Masquerade? Masquerade { get; set; }

    public Message()
        : this(null, "", "")
    {}
    public Message(string id, string channelId)
        : this(null, id, channelId)
    {}

    internal Message(Client? client, string id, string channelId)
        : base(client)
    {
        Client = client;
        Id = id;
        ChannelId = channelId;
        
        Reactions = new Dictionary<string, string[]>();
    }

    internal async Task<Message?> Fetch(Client client, string channelId, string messageId)
    {
        var message = new Message
        {
            ChannelId = channelId,
            Id = messageId
        };
        if (await message.Fetch(client))
            return message;
        return null;
    }
    /// <summary>
    /// Fetch latest information about this message from the API.
    /// </summary>
    /// <returns>Did it successfully fetch and inject the latest data from the API</returns>
    public async Task<bool> Fetch(Client client)
    {
        var response = await client.GetAsync($"/channels/{ChannelId}/messages/{Id}");
        if (response.StatusCode != HttpStatusCode.OK)
            return false;

        var stringContent = response.Content.ReadAsStringAsync().Result;
        var data = Parse(stringContent);
        if (data == null)
            return false;
        
        Inject(data, this);
        return true;
    }

    public Task<bool> Fetch()
        => Fetch(Client);
    
    /// <summary>
    /// Parse a JSON as a message. This is used for properly deserializing the <see cref="Embeds"/> field since the item type can be many things.
    /// </summary>
    /// <param name="content">JSON content of the message</param>
    /// <returns>Properly parsed message, null when <see cref="JsonSerializer"/> fails</returns>
    public static Message? Parse(string content)
    {
        var data = JsonSerializer.Deserialize<Message>(content, Client.SerializerOptions);
        if (data == null)
            return null;
        data.Embeds = MessageHelper.ParseMessageEmbeds(content);
        data.SystemMessage = MessageHelper.ParseSystemMessage(content);
        return data;
    }

    internal static void Inject(Message source, Message target)
    {
        target.Id = source.Id;
        target.Nonce = source.Nonce;
        target.ChannelId = source.ChannelId;
        target.AuthorId = source.AuthorId;
        target.Content = source.Content;
        target.SystemMessage = source.SystemMessage;
        target.Attachments = source.Attachments;
        target.EditedAt = source.EditedAt;
        target.Embeds = source.Embeds;
        target.MentionIds = source.MentionIds;
        target.MessageReplyIds = source.MessageReplyIds;
        target.Reactions = source.Reactions;
        target.Interactions = source.Interactions;
        target.Masquerade = source.Masquerade;
    }

    /// <summary>
    /// Invoked when this message is reacted to.
    /// </summary>
    public event MessageReactedDelegate ReactAdd;
    internal void OnReactAdd(string userId, string react)
    {
        if (Reactions.ContainsKey(react))
        {
            Reactions[react] = Reactions[react].Concat(new string[] { userId }).ToArray();
        }
        else
        {
            Reactions.Add(react, new string[]
            {
                userId
            });
        }
        ReactAdd?.Invoke(userId, react, Id);
    }

    /// <summary>
    /// Invoked when a reaction was removed from this message.
    /// </summary>
    public event MessageReactedDelegate ReactRemove;

    internal void OnReactRemove(string userId, string react)
    {
        if (Reactions.ContainsKey(react))
            Reactions[react] = Reactions[react].Where(v => v != userId).ToArray();
        ReactRemove?.Invoke(userId, react, Id);
    }
}
